
Need an "ImageSink" superclass, upon which CachedImage, PixbufFromImageSource and the Image Savers will be based.
The sinks will have a ProcessRow() function, as well as a ProcessImage(Progress &) function.
The advantage of this is that several imagesinks can in this way operate on the same image, like so:
ImageSource *source=ISLoadImage("filename");
CachedImage img1(new ImageSource_Tee(source));
CachedImage img2(new ImageSource_Tee(source));
TIFFSaver saver("filenameout",source);

for(int row=0;row<source->height;++row)
{
	img1.ProcessRow(row);
	img2.ProcessRow(row);
	saver.ProcessRow(row);
}

class ImageSink
{
	public:
	ImageSink(ImageSource *source) : source(source)
	{
	}
	virtual ~ImageSink()
	{
		if(source)
			delete source;
	}
	virtual bool ProcessImage(Progress *prog=NULL)
	{
		for(int i=0;i<source->height;++i)
		{
			ProcessRow(i);
			if(prog)
			{
				if(!prog->DoProgress(i,source->height-1))
				return(false);
			}
		}
		return(true);
	}
	virtual void ProcessRow(int row)
	{
	}
	protected:
	ImageSource *source;
};

Need a variant of the JobQueue system for handling UI events, to avoid the problems currently caused by events being pumped from within signal handlers.

Investigate using smart pointers for ref counting and figure out how that would interact with gtk idle handlers.
Need to use a map between addresses and refcounters; merely using a templated class will cause problems with polymorphism.

